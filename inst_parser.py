#
#
#

import fnmatch
#from inst import *

INST = {
'1100***10000****': 'ABCD',
'1101************': 'ADD',
'1101************': 'ADDA',
'00000110********': 'ADDI',
'0101***0********': 'ADDQ',
'1101***1**00****': 'ADDX',
'1100************': 'AND',
'00000010********': 'ANDI',
'0000001000111100': 'ANDIC',
'1110*******00***': 'ASL',	# COME BACK TO THIS
'1110*******00***': 'ASR',  # THIS ONE TOO
'0110************': 'BCC',  # *IS CASE SENSITIVE?
'0000***101******': 'BCHG',
'0000***110******': 'BCLR',
'1110101011******': 'BFCHG',
'1110110011******': 'BFCLR',
'1110101111******': 'BFEXTS',
'1110100111******': 'BFEXTU',
'1110100111******': 'BFFFO',
'1110111111******': 'BFINS',
'1110111011******': 'BFSET',
'1110100011******': 'BFTST',
'0100100001001***': 'BKPT',
'01100000********': 'BRA',
'0000***111******': 'BSET',
'01100001********': 'BSR',
'0000***100******': 'BTST',
'0000011011******': 'CALLM',
'00001**011******': 'CAS',
'00001**011111100': 'CAS2',
'0100*****0******': 'CHK',
'00000**011******': 'CHK2',
'01000010********': 'CLR',
'1011************': 'CMP',
'1011************': 'CMPA',
'00001100********': 'CMPI',
'1011***1**001***': 'CMPM',
'0101****11001***': 'DBCC', # *
'1000***111******': 'DIVS',
'0100110001******': 'DIVSL',
'1000***011******': 'DIVU',
'0100110001******': 'DIVUL',
'1011************': 'EOR',
'00001010********': 'EORI',
'0000101000111100': 'EORIC',
'1100***1********': 'EXG',
'0100100010000***': 'EXT.W',
'0100100011000***': 'EXT.L',
'0100100111000***': 'EXTB.L',
'0100101011111100': 'ILLEGAL',
'0100111011******': 'JMP',
'0100111010******': 'JSR',
'0100***111******': 'LEA',
'0100111001010***': 'LINK',
'1110*******01***': 'LSL',
'1110001*11******': 'LSR',
'00**************': 'MOVE',
'00*****001******': 'MOVEA',
'0100001011******': 'MOVEFC', # From CCR
'0100010011******': 'MOVETC', # To CCR
'0100000011******': 'MOVEFS', # From SR
'01001*001*******': 'MOVEM',
'0000******001***': 'MOVEP',
'0111***0********': 'MOVEQ',
'1100***111******': 'MULS',
'1100***011******': 'MULU',
'0100100000******': 'NBCD',
'01000100********': 'NEG',
'01000000********': 'NEGX',
'0100111001110001': 'NOP',
'01000110********': 'NOT',
'1000************': 'OR',
'00000000********': 'ORI',
'0000000000111100': 'ORIC', # To CCR
'0100100001******': 'PEA',
'1110***1***11***': 'ROL',
'1110***0***11***': 'ROR',
'1110011111******': 'ROLM',
'1110011011******': 'RORM',
'1110***1***10***': 'ROXL',
'1110***0***10***': 'ROXR',
'1110010111******': 'ROXLM',
'1110010011******': 'ROXRM',
'0100111001110100': 'RTD',
'000001101100****': 'RTM',
'0100111001110111': 'RTR',
'0100111001110101': 'RTS',
'1000***10000****': 'SBCD',
'0101****11******': 'SCC', # *
'1001************': 'SUB',
'1001************': 'SUBA',
'00000100********': 'SUBI',
'0101***1********': 'SUBQ',
'1001***1**00****': 'SUBX',
'0100100001000***': 'SWAP',
'0100101011******': 'TAS',
'010011100100****': 'TRAP',
'0100111001110110': 'TRAPV',
'01001010********': 'TST',
'0100111001011***': 'UNLK'
}

WORD = 2

def readByte(F, n):
	return bin(int.from_bytes(f.read(n), byteorder='big'))

def readByteBits(F, n):
	return byteToBit(readByte(F, n))

def byteToBit(B):
	return [int(x) for x in list(B[2:])]

def padToLength(L, N): 
	[L.insert(0, 0) for i in range(N - len(L))]
	return L

def inst(B):
	fnmatch.filter()

with open("ti89tv310.rom", "rb") as f:
    word = readByteBits(f, WORD)
    while word != "":
        inst(padToLength(word, 16))
        word = readByteBits(f, WORD)
